#!/usr/bin/env node
const dotenv     = require('dotenv').config()
const pkg        = require('../package.json')
const ta         = require('../index')
const time       = require('../time')
const utils      = require('../utils')
const pipeline   = require('../pipeline')
const ix         = require('../indicators')
const strategies = require('../strategies')
const research   = require('../research')
const simulator  = require('../exchanges/simulator')
const luxon      = require('luxon')
const commander  = require('commander')
const talib      = require('talib')
const beautify   = require('json-beautify')
const merge      = require('lodash.merge')
const pino       = require('pino')


const {DateTime} = luxon

const logger = pino()

const parseIntB10 = utils.parseIntB10

const DEFAULT_STRATEGY = 'BuyAndHold'

function lookupStrategy(pr) {
  let init
  if (pr.research) {
    init = research[pr.research]
  } else {
    init = strategies[pr.strategy]
  }
  if (!init) {
    const strategyType = pr.research ? 'Research Strategy' : 'Trading Strategy'
    const strategyName = pr.research ? pr.research : pr.strategy
    console.error(`${strategyType} "${strategyName}" not found.`)
    if (pr.research) {
      console.log(Object.keys(research))
    } else {
      console.log(Object.keys(strategies))
    }
    process.exit(-1)
  }
  return init
}

function parseDateTime(d) {
  return DateTime.fromISO(d)
}

async function main() {
  const program   = new commander.Command();
  program
    .version(pkg.version)
    .description('Backtest a trading strategy against historical price data')
    .option('-x, --exchange <NAME>', 'Exchange to pull data from', process.env.TA_EXCHANGE)
    .option('-m, --market <SYMBOL>', 'Market in exchange to pull data from', process.env.TA_MARKET)
    .option('-t, --timeframe <INTERVAL>', 'Candlestick duration for market data', process.env.TA_TIMEFRAME)
    .option('-d, --data <PATH>', 'Directory to store candlestick data in', './data')
    .option('-s, --strategy <STRATEGY>', 'Name of trading strategy to use', DEFAULT_STRATEGY)
    .option('-r, --research <STRATEGY>', 'Use a strategy from the research collection instead')
    .option('-c, --config <CONFIG.JSON>', 'Path to a JSON config file for the strategy')
    .option('-b, --balance <DOLLARS>', 'Amount of money to start with', parseIntB10, 100000)
    .option('--start-processing-at <DATETIME>', 'Refrain from indicator calculation until the given DateTime is reached', parseDateTime)
    .option('--begin <DATETIME>', 'DateTime to begin the strategy', parseDateTime)
    .option('--end <DATETIME>', 'DateTime to end the strategy', parseDateTime)
    .option('-v, --verbose', 'Be verbose')
  program.parse(process.argv)
  let optionsAreMissing = false;
  ['exchange', 'market', 'timeframe'].forEach((opt) => {
    if (!program[opt]) {
      console.error(`The --${opt} option is required.`)
      optionsAreMissing = true
    }
  })
  if (optionsAreMissing) {
    process.exit(-1)
  }
  if (program.strategy !== DEFAULT_STRATEGY && program.research) {
    console.error(`You can't use --strategy and --research at the same time.  Pick one and only one.`)
    process.exit(-1)
  }
  if (program.begin && program.startProcessingAt) {
    if (program.begin < program.startProcessingAt) {
      console.error("--start-processing-at must have an earlier DateTime than --begin.")
      process.exit(-1)
    }
  }
  try {
    /*
     * I need an execution environment.
     * The strategy has to ask for some things upfront.
     * - What indicators do you want on which timeframes?
     * - The environment must be able to emulate larger timeframes by aggregating smaller timeframes.
     * The execution environment has to provide the data that the strategy asks for.
     * - I have a way of downloading candles now.
     * - I may want to standardize how I store them so that I can predictably retrieve them.
     *   + `${exchange}/${market}/${timeframe}/${timestamp}.json`
     *   + files are assumed to be in numeric order and without gaps
     * The analysis state should change as new data comes in.
     * Based on the analysis state, orders should be placed by the strategy when appropriate.
     */

    // Let's feel this out.

    // Exchange Simulator
    let config = { balance: program.balance, logger }
    const exchange = simulator.create(config)

    // Strategy
    let strategyConfig
    if (program.config) {
      const configPath = `${process.cwd()}/${program.config}`
      const jsonConfig = require(configPath)
      strategyConfig = merge(config, jsonConfig)
    } else {
      strategyConfig = config
    }
    const strategyInit = lookupStrategy(program)
    const [indicatorSpecs, strategy] = strategyInit(program.timeframe, strategyConfig)
    indicatorSpecs.inverted = true // force the pipeline to use the InvertedSeries data structure.
    if (program.verbose) {
      console.log('indicatorSpecs', indicatorSpecs)
    }

    // Pipeline of Price Data
    const iterate = pipeline.mainLoopFn(program.timeframe, indicatorSpecs)
    const nextCandle = await pipeline.loadCandlesFromFS(program.data, program.exchange, program.market, program.timeframe, program.startProcessingAt)

    // Mutable Variables
    let orders
    let marketState
    let exchangeState, executedOrders
    let candle = await nextCandle()
    let firstTimestamp = time.dt(candle[0])
    let startProcessing
    let begin
    let end = false
    if (program.startProcessingAt) {
      startProcessing = firstTimestamp >= program.startProcessingAt
    } else {
      startProcessing = true
    }
    if (program.begin) {
      begin = firstTimestamp >= program.begin
    } else {
      if (program.startProcessingAt) {
        begin = false
      } else {
        begin = true
      }
    }
    if (program.verbose) {
      if (program.startProcessingAt) {
        console.log('start-processing-at', program.startProcessingAt.toISO(), startProcessing)
      }
      if (program.begin) {
        console.log('begin', program.begin.toISO(), begin)
      }
      if (program.end) {
        console.log('end', program.end.toISO(), end)
      }
      console.log('---- while loop')
    }
    console.log({ begin, end, startProcessing })
    while (candle && !end) {
      if (startProcessing) {
        marketState = iterate(candle)
      }
      if (program.verbose) {
        if (time.isTimeframeBoundary('1d', time.dt(candle[0]))) {
          console.log(time.dt(candle[0]).toISO(), candle)
        }
      }
      if (begin) {
        orders = strategy(marketState, executedOrders)
        ;[exchangeState, executedOrders] = exchange(exchangeState, orders, candle)
        if (orders && orders.length) {
          console.log({ candle, orders })
        }
      }
      candle = await nextCandle()

      // Check candle[0] for begin and end conditions
      if (candle) {
        let timestamp = time.dt(candle[0])
        if (!begin) {
          begin = timestamp >= program.begin
          if (begin && program.verbose) {
            console.log('starting strategy at', timestamp.toISO())
          }
        }
        if (program.end && candle) {
          end = timestamp > program.end
          if (end && program.verbose) {
            console.log('ending strategy at', timestamp.toISO())
          }
        }
        if (!startProcessing) {
          startProcessing = timestamp >= program.startProcessingAt
          if (startProcessing && program.verbose) {
            console.log('start processing at', timestamp.toISO())
          }
          if (startProcessing && !program.begin) {
            begin = true
            if (program.verbose) {
              console.log('starting strategy at', timestamp.toISO())
            }
          }
        }
      }
    }

    // What's the damage?
    console.log(exchangeState)
    const key = `imd${program.timeframe}`
    const close = marketState[key].close[0]
    console.log('Closing Price', close)
    console.log('Equity', (close * exchangeState.position) + exchangeState.balance)
  }
  catch (err) {
    console.error(err.stack)
    process.exit(-1)
  }
}

main()
