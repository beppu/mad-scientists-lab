const talib = require('talib')
const ta = require('../index')
const ema = require('./ema')
const clone = require('clone')

let candles

function initializeCandles() {
  candles = require('../tests/fixtures/candles.json')
}

beforeEach(() => {
  initializeCandles()
})

test('EMA stream calculations should be consistent with EMA batch calculations', () => {
  const period = 5
  const key = `ema${period}`

  // stream calculation
  let md = ta.marketDataFromCandles([])
  let imd = ta.invertedMarketData(md)
  const [emaInsert, emaUpdate] = ema(period)
  let state
  candles.forEach((c) => {
    md = ta.marketDataAppendCandle(md, c)
    imd = ta.invertedAppendCandle(imd, c)
    state = emaInsert(md, imd, state)
  })

  // batch calculation copied and adapted from bin/price
  const marketData         = ta.marketDataFromCandles(candles)
  const indicatorSettings  = ta.id.ema(marketData, period)
  const r                  = talib.execute(indicatorSettings)
  const invertedMarketData = ta.invertedMarketData(marketData)
  ta.invertedAppend(invertedMarketData, key, r.result.outReal)

  // batch and stream should have the same values
  //console.warn(invertedMarketData[key], imd[key])
  //console.warn(invertedMarketData[key])
  expect(invertedMarketData[key]).toEqual(imd[key])
})

test('EMA stream update calculations should be correct and not corrupt the calculations', () => {
  const period = 5
  const key = `ema${period}`

  // do batch calculation for comparison in later tests
  const marketData         = ta.marketDataFromCandles(candles)
  const indicatorSettings  = ta.id.ema(marketData, period)
  const r                  = talib.execute(indicatorSettings)
  const invertedMarketData = ta.invertedMarketData(marketData)
  ta.invertedAppend(invertedMarketData, key, r.result.outReal)

  // stream calculation
  let md = ta.marketDataFromCandles([])
  let imd = ta.invertedMarketData(md)
  const [emaInsert, emaUpdate] = ema(period)
  let state
  let minimumCandles = candles.slice(0, period)
  minimumCandles.forEach((c) => {
    md = ta.marketDataAppendCandle(md, c)
    imd = ta.invertedAppendCandle(imd, c)
    state = emaInsert(md, imd, state)
  })
  //console.warn(`${key} after ${period} candles`, imd[key], state)
  expect(imd[key]).toHaveLength(1)

  // I have to get this right.
  // What is the correct shape of this loop?

  // emaInsert with previous state on exit of timeframe boundary.
  let md2 = clone(md)
  let imd2 = clone(imd)
  const c2 = [ candles[period][0], candles[period][1], 1000, 1000, 1000, 1000 ] // insert a fake candle
  md2 = ta.marketDataAppendCandle(md2, c2)
  imd2 = ta.invertedAppendCandle(imd2, c2)
  emaInsert(md2, imd2, state)
  expect(imd2[key]).toHaveLength(2)
  //console.warn('append fake next candle', c2)

  // emaUpdate while inside timeframe boundary
  const c3 = [ c2[0], 1000, 1100, 1000, 1100, 2000 ]
  md2 = ta.marketDataUpdateCandle(md2, c3)
  imd2 = ta.invertedUpdateCandle(imd2, c3)
  emaUpdate(md, imd, state)
  expect(imd2[key]).toHaveLength(2) // length should not change from previous iteration
  //console.warn('after emaUpdate', imd2[key])

  // use real candle to finalize last update
  const c4 = candles[period] // use real candle to finalize the last update
  md2 = ta.marketDataUpdateCandle(md2, c4)
  imd2 = ta.invertedUpdateCandle(imd2, c4)
  let state2 = emaUpdate(md2, imd2, state)
  //console.warn('update with real candle', c4)
  // our most recent ema should equal the second to the last from the batch calculation
  expect(imd2[key][0]).toEqual(invertedMarketData[key][ invertedMarketData[key].length - 2 ])

  // when inserting a new candle, I have to use the lastState generated by the final emaUpdate
  const c5 = candles[period+1]
  md2 = ta.marketDataUpdateCandle(md2, c5)
  imd2 = ta.invertedUpdateCandle(imd2, c5)
  let state3 = emaUpdate(md2, imd2, state2)
  expect(imd2[key][0]).toEqual(invertedMarketData[key][ invertedMarketData[key].length - 3])

  // The math seems ok, but structuring the loop to aggregate and calculate in sync is tricky.
  // Writing this test helped me figure out the correct structure of the loop.
})
